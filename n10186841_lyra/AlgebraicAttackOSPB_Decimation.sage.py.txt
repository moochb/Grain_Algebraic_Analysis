

# This file was *autogenerated* from the file AlgebraicAttackOSPB_Decimation.sage
from sage.all_cmdline import *   # import sage library

_sage_const_70 = Integer(70); _sage_const_2 = Integer(2); _sage_const_1 = Integer(1); _sage_const_256 = Integer(256); _sage_const_6 = Integer(6); _sage_const_4 = Integer(4); _sage_const_3 = Integer(3); _sage_const_7 = Integer(7); _sage_const_5 = Integer(5); _sage_const_0 = Integer(0); _sage_const_207 = Integer(207); _sage_const_200 = Integer(200); _sage_const_8 = Integer(8); _sage_const_10 = Integer(10); _sage_const_12 = Integer(12); _sage_const_14 = Integer(14); _sage_const_16 = Integer(16); _sage_const_18 = Integer(18); _sage_const_20 = Integer(20); _sage_const_22 = Integer(22); _sage_const_24 = Integer(24); _sage_const_26 = Integer(26); _sage_const_28 = Integer(28); _sage_const_30 = Integer(30); _sage_const_32 = Integer(32); _sage_const_34 = Integer(34); _sage_const_36 = Integer(36); _sage_const_38 = Integer(38); _sage_const_40 = Integer(40)
n = _sage_const_70 
#define polynomial ring in which the initial state variables and the keystream bits exist
R = PolynomialRing(GF(_sage_const_2 ), names=('s0', 's1', 's2', 's3', 's4', 's5', 'y0', 'y1', 'y2', 'y3', 'y4', 'y5', 'y6', 'y7', 'y8', 'y9', 'y10', 'y11', 'y12', 'y13', 'y14', 'y15', 'y16', 'y17', 'y18', 'y19', 'y20', 'y21', 'y22', 'y23', 'y24', 'y25', 'y26', 'y27', 'y28', 'y29', 'y30', 'y31', 'y32', 'y33', 'y34', 'y35', 'y36', 'y37', 'y38', 'y39', 'y40', 'y41', 'y42', 'y43', 'y44', 'y45', 'y46', 'y47', 'y48', 'y49', 'y50', 'y51', 'y52', 'y53', 'y54', 'y55', 'y56', 'y57', 'y58', 'y59', 'y60', 'y61', 'y62', 'y63', 'y64',)); (s0, s1, s2, s3, s4, s5, y0, y1, y2, y3, y4, y5, y6, y7, y8, y9, y10, y11, y12, y13, y14, y15, y16, y17, y18, y19, y20, y21, y22, y23, y24, y25, y26, y27, y28, y29, y30, y31, y32, y33, y34, y35, y36, y37, y38, y39, y40, y41, y42, y43, y44, y45, y46, y47, y48, y49, y50, y51, y52, y53, y54, y55, y56, y57, y58, y59, y60, y61, y62, y63, y64,) = R._first_ngens(71)

R1 = PolynomialRing(GF(_sage_const_2 ), names=('s0', 's1', 's2', 's3', 's4', 's5',)); (s0, s1, s2, s3, s4, s5,) = R1._first_ngens(6)
#create a matrix 's' to hold the initial state variables
s = [s0,s1,s2,s3,s4,s5]

#create a matrix to hold all the output variables
Y = [y0,y1,y2,y3,y4,y5,y6,y7,y8,y9,y10,y11,y12,y13,y14,y15,y16,y17,y18,y19,y20,y21,y22,y23,y24,y25,y26,y27,y28,y29,y30,y31,y32,y33,y34,y35,y36,y37,y38,y39,y40,y41,y42,y43,y44,y45,y46,y47,y48,y49,y50,y51,y52,y53,y54,y55,y56,y57,y58,y59,y60,y61,y62,y63,y64]
# [1, 1, 1, 1, 0, 1, 1]
# O= [0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 1, 0, 0, 1, 1, 1, 0, 0, 0, 1, 0, 1, 1, 1, 1, 0, 0, 1, 0, 1, 0, 0, 0, 1, 1, 1, 0, 1, 1, 1, 1, 0, 0, 1, 0, 1, 0, 0, 0, 1, 1, 0, 0, 0, 1, 1, 1, 1, 0, 1, 0, 1, 1, 1, 1, 1, 0, 1, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 0, 1, 1, 0, 0, 1, 1, 0, 1, 0, 1, 1, 0, 1, 1, 1, 0, 1, 1, 0, 0, 0, 1, 0, 0, 1, 1, 1, 0, 1, 0, 1, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 1, 0, 0, 1, 1, 1, 0, 0, 0, 1, 0, 1, 1, 1, 1, 0, 0, 1, 0, 1, 0, 0, 0, 1, 1, 1, 0, 1, 1, 1, 1, 0, 0, 1, 0, 1, 0, 0, 0, 1, 1, 0, 0, 0, 1, 1, 1, 1, 0, 1, 0, 1, 1, 1]


#We can consider 's' as a register that will be shifted for a specified number of times. Thus, there will exist more entries than simply those defined in 's'.
#We therefore initialise a vector 'add' that will be appended to s to hold all the update bits (one vector for equations with respect to keystream bits S and one with respect the the linear approximation G).
add=list(0for i in (ellipsis_iter(_sage_const_1 ,Ellipsis,_sage_const_256 )))
S = s+add
G = s+add

#Generate equations for update using output bits
# S[6] = S[0]+S[2]+S[3]+O[0]
for i in range(_sage_const_6 ,n):
    S[i] = (S[i-_sage_const_6 ]+S[i-_sage_const_4 ]+S[i-_sage_const_3 ]+Y[i-_sage_const_6 ])
    # S[i] = (S[i-6]+S[i-5]+S[i-4]+S[i-1]+O[i-6])
#     S[i] = (S[i-6]+S[i-3]+O[i-6])
    # S[i] = (S[i-6]+S[i-5]+S[i-2]+S[i-1]+O[i-6])
    # S[i] = (S[i-6]+S[i-4]+O[i-6])
    #S[i] = (S[i-4]+S[i-3]+O[i-6])
    # S[i] = (S[i-5]+S[i-4]+S[i-1]+O[i-6])

    # print(i, S[i])

#Generate equations for update using linear approximation
for i in range(_sage_const_7 ,n):
    #G_approx = s1+s2+s6 with bias agreeing 48 for the true update function s1+s2+s6+s3s5s7
    G[i] = S[i-_sage_const_7 ]+S[i-_sage_const_6 ]+S[i-_sage_const_2 ]+S[i-_sage_const_5 ]*S[i-_sage_const_3 ]*S[i-_sage_const_1 ]
#   

    #G_approx = r0+r1 with bias agreeing 48 for the true update function  r0 + r1 + r2r3 + r4r5r6.
    # G[i] = S[i-7]+S[i-6]
    
    #G_approx = r0+r1+r2 with bias agreeing 48 for the true update function  r0 + r1 + r2r3 + r4r5r6.
    # G[i] = S[i-7]+S[i-6]+S[i-5]
    
    #G_approx = r0+r1+r3 with bias agreeing 48 for the true update function  r0 + r1 + r2r3 + r4r5r6.
    # G[i] = S[i-7]+S[i-6]+S[i-4]
    
    #G_approx = r0+r1+r2+r3 with bias agreeing 48 for the true update function  r0 + r1 + r2r3 + r4r5r6.
    # G[i] = S[i-7]+S[i-6]+S[i-5]+S[i-4]
    
    #G_approx = s1+s2+s3 with bias agreeing 24 for the true update function s1+s2+s3s4+s5s6s7
    # G[i] = S[i-7]+S[i-6]+S[i-5]
    #G_approx = s1+s2+s3 with bias agreeing 24 for the true update function s1+s2+s3s4+s5s6s7
    # G[i] = S[i-7]+S[i-6]+S[i-4]
    #G_approx = s1+s2+s3+s4 with bias agreeing 24 for the true update function s1+s2+s3s4+s5s6s7
    # G[i] = S[i-7]+S[i-6]+S[i-5]+S[i-4]
#     G[i] = S[i-6]+S[i-5]
    
    
    
    # print(i,G[i])
    #create a matrix that will hold the final equations (the sum of those given with respect to the keystream bits + those given by the linear approximation)
EQ = list(var('eq%d' %i) for i in (ellipsis_iter(_sage_const_0 ,Ellipsis,_sage_const_256 )))


# Combine both forms of equations
# print(S)
# print(G)
for i in range(_sage_const_7 ,n):
    EQ[i] = (S[i]+G[i])
    # print(i,EQ[i])
# for i in range(7,40):
    # print(i,EQ[i])
#
EQ_1=EQ[_sage_const_7 :n]
# 


#BUILD OUTPUT

V = [_sage_const_0 ,_sage_const_0 ,_sage_const_0 ,_sage_const_0 ,_sage_const_0 ,_sage_const_0 ,_sage_const_0 ]

#Define nonlinear feedback variable
fS = var('fS')


#initialise a random initial vector
for i in range(_sage_const_7 ):
    # V[i]= ntl.ZZ_random(2)
    V = [_sage_const_1 , _sage_const_0 , _sage_const_1 , _sage_const_0 , _sage_const_0 , _sage_const_0 , _sage_const_1 ]
    # V = [0, 1, 0, 1, 0, 0, 1]
#     V = [1, 1, 1, 1, 0, 1, 1]
#     V = [1, 1, 1, 0, 0, 1, 1]
# print(V)
#Define register S
RegS = [_sage_const_0 ]*len(V)
for i in range(len(V)):
    RegS[i] = V[i]
print(V)
b = [_sage_const_0 ]*_sage_const_207 
#initialise a vector for the keystream
O = [_sage_const_0 ]*_sage_const_200 

for i in range(len(V)):
    b[i] = V[i]
#we will only produce exactly as much keystream is needed to check our assumption
for i in range(_sage_const_200 ):
#
   # Generate ouput bit z
    O[i] = mod((RegS[_sage_const_0 ]+RegS[_sage_const_2 ]+RegS[_sage_const_3 ]+RegS[_sage_const_6 ]),_sage_const_2 )

    #Calculate feedback bit for RegS (NONLINEAR)
    # fS= mod((RegS[0]+RegS[1]+RegS[5]+(RegS[2]*RegS[4]*RegS[6])),2)
    fS= mod((RegS[_sage_const_0 ]+RegS[_sage_const_1 ]+RegS[_sage_const_5 ]+(RegS[_sage_const_2 ]*RegS[_sage_const_4 ]*RegS[_sage_const_6 ])),_sage_const_2 )

    b[i+_sage_const_7 ] = fS
#
   # Step register S by one and enter feedback into lsb
    for i in range(_sage_const_6 ):
        RegS[i]=RegS[i+_sage_const_1 ]

    RegS[_sage_const_6 ] = fS
# print(EQ[8])
# print(EQ_1[0])
# print(EQ_1[1])
# print(EQ_1[31])
# print(EQ_1[32])
# I = R.ideal(EQ_1) ;
# I.variety()
#V = [1, 0, 1, 0, 0, 0, 1]
O[_sage_const_0 :_sage_const_5 ]
# O = [0, 1, 1, 0, 1, 0, 0, 1, 0, 0, 1, 1, 1, 0, 0, 0, 1, 0, 1, 1, 1, 0, 0, 0, 1, 0, 0, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 1, 0, 1, 1, 0, 1, 0, 0, 0, 0, 1, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 1, 0, 0, 0, 1, 0, 1, 0, 1, 1, 0, 1, 0, 0, 1, 0, 0, 1, 1, 1, 0, 0, 0, 1, 0, 1, 1, 1, 0, 0, 0, 1, 0, 0, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 1, 0, 1, 1, 0, 1, 0, 0, 0, 0, 1, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 1, 0, 0, 0, 1, 0, 1, 0, 1, 1, 0, 1, 0, 0, 1, 0, 0, 1, 1, 1, 0, 0, 0, 1, 0, 1, 1, 1, 0, 0, 0, 1, 0, 0, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 1, 0, 1, 1, 0, 1, 0, 0, 0, 0, 1, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0]
len(EQ_1)
# for i in range(len(EQ_1)):
#     EQ_1[i]=EQ_1[i].subs(y0=O[0], y1=O[1], y2=O[2], y3=O[3], y4=O[4], y5=O[5], y6=O[6], y7=O[7], y8=O[8], y9=O[9], y10=O[10], y11=O[11], y12=O[12], y13=O[13], y14=O[14], y15=O[15], y16=O[16], y17=O[17], y18=O[18], y19=O[19], y20=O[20], y21=O[21], y22=O[22], y23=O[23], y24=O[24], y25=O[25], y26=O[26], y27=O[27], y28=O[28], y29=O[29], y30=O[30], y31=O[31], y32=O[32], y33=O[33], y34=O[34], y35=O[35], y36=O[36], y37=O[37], y38=O[38], y39=O[39], y40=O[40], y41=O[41], y42=O[42], y43=O[43], y44=O[44], y45=O[45], y46=O[46], y47=O[47], y48=O[48], y49=O[49], y50=O[50], y51=O[51], y52=O[52], y53=O[53], y54=O[54], y55=O[55], y56=O[56], y57=O[57], y58=O[58], y59=O[59], y60=O[60], y61=O[61], y62=O[62], y63=O[63], y64=O[64])


#Partial decimation (up to 40)
for i in range(len(EQ_1)):
    EQ_1[i]=EQ_1[i].subs(y0=O[_sage_const_0 ], y2=O[_sage_const_2 ], y4=O[_sage_const_4 ], y6=O[_sage_const_6 ], y8=O[_sage_const_8 ],y10=O[_sage_const_10 ], y12=O[_sage_const_12 ], y14=O[_sage_const_14 ], y16=O[_sage_const_16 ], y18=O[_sage_const_18 ], y20=O[_sage_const_20 ], y22=O[_sage_const_22 ], y24=O[_sage_const_24 ], y26=O[_sage_const_26 ], y28=O[_sage_const_28 ], y30=O[_sage_const_30 ],y32=O[_sage_const_32 ], y34=O[_sage_const_34 ], y36=O[_sage_const_36 ], y38=O[_sage_const_38 ], y40=O[_sage_const_40 ])


#Define the polynomial ring over which the equations will be solved (partial decimation up to y6)
R1 = PolynomialRing(GF(_sage_const_2 ), names=('s0', 's1', 's2', 's3', 's4', 's5', 'y1', 'y3', 'y5', 'y7', 'y9', 'y11', 'y13', 'y15', 'y17', 'y19', 'y21', 'y23', 'y25', 'y27', 'y29', 'y31', 'y33', 'y35', 'y37', 'y39',)); (s0, s1, s2, s3, s4, s5, y1, y3, y5, y7, y9, y11, y13, y15, y17, y19, y21, y23, y25, y27, y29, y31, y33, y35, y37, y39,) = R1._first_ngens(26)

#Define the polynomial ring over which the equations will be solved (full decimation up to y40)
# R1.<s0,s1,s2,s3,s4,s5,y1,y3,y5,y7,y9,y11,y13,y15,y17,y19,y21,y23,y25,y27,y29,y31,y33,y35,y37,y39> = PolynomialRing(GF(2))
# print(EQ_1[62])
# Consider the system of equations as an ideal over a polynomial ring R1
I = R1.ideal(EQ_1[_sage_const_0 :_sage_const_40 ])
# print(len(I))
# What initial values satisfy this ideal
J = I.variety()
# 
#Print initial values
print(J)

#Print 'n' as proof the code has finished
print(n)



