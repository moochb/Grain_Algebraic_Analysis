

# This file was *autogenerated* from the file OSPB_Algebraic.sage
from sage.all_cmdline import *   # import sage library

_sage_const_70 = Integer(70); _sage_const_2 = Integer(2); _sage_const_1 = Integer(1); _sage_const_256 = Integer(256); _sage_const_6 = Integer(6); _sage_const_4 = Integer(4); _sage_const_3 = Integer(3); _sage_const_7 = Integer(7); _sage_const_5 = Integer(5); _sage_const_0 = Integer(0); _sage_const_207 = Integer(207); _sage_const_200 = Integer(200); _sage_const_8 = Integer(8); _sage_const_9 = Integer(9); _sage_const_10 = Integer(10); _sage_const_11 = Integer(11); _sage_const_12 = Integer(12); _sage_const_13 = Integer(13); _sage_const_14 = Integer(14); _sage_const_15 = Integer(15); _sage_const_16 = Integer(16); _sage_const_17 = Integer(17); _sage_const_18 = Integer(18); _sage_const_19 = Integer(19); _sage_const_20 = Integer(20); _sage_const_21 = Integer(21); _sage_const_22 = Integer(22); _sage_const_23 = Integer(23); _sage_const_24 = Integer(24); _sage_const_25 = Integer(25); _sage_const_26 = Integer(26); _sage_const_27 = Integer(27); _sage_const_28 = Integer(28); _sage_const_29 = Integer(29); _sage_const_30 = Integer(30); _sage_const_31 = Integer(31); _sage_const_32 = Integer(32); _sage_const_33 = Integer(33)
n = _sage_const_70 
#define polynomial ring in which the initial state variables and the keystream bits exist
R = PolynomialRing(GF(_sage_const_2 ), names=('s0', 's1', 's2', 's3', 's4', 's5', 'y0', 'y1', 'y2', 'y3', 'y4', 'y5', 'y6', 'y7', 'y8', 'y9', 'y10', 'y11', 'y12', 'y13', 'y14', 'y15', 'y16', 'y17', 'y18', 'y19', 'y20', 'y21', 'y22', 'y23', 'y24', 'y25', 'y26', 'y27', 'y28', 'y29', 'y30', 'y31', 'y32', 'y33', 'y34', 'y35', 'y36', 'y37', 'y38', 'y39', 'y40', 'y41', 'y42', 'y43', 'y44', 'y45', 'y46', 'y47', 'y48', 'y49', 'y50', 'y51', 'y52', 'y53', 'y54', 'y55', 'y56', 'y57', 'y58', 'y59', 'y60', 'y61', 'y62', 'y63', 'y64',)); (s0, s1, s2, s3, s4, s5, y0, y1, y2, y3, y4, y5, y6, y7, y8, y9, y10, y11, y12, y13, y14, y15, y16, y17, y18, y19, y20, y21, y22, y23, y24, y25, y26, y27, y28, y29, y30, y31, y32, y33, y34, y35, y36, y37, y38, y39, y40, y41, y42, y43, y44, y45, y46, y47, y48, y49, y50, y51, y52, y53, y54, y55, y56, y57, y58, y59, y60, y61, y62, y63, y64,) = R._first_ngens(71)

R1 = PolynomialRing(GF(_sage_const_2 ), names=('s0', 's1', 's2', 's3', 's4', 's5',)); (s0, s1, s2, s3, s4, s5,) = R1._first_ngens(6)
#create a matrix 's' to hold the initial state variables
s = [s0,s1,s2,s3,s4,s5]

#create a matrix to hold all the output variables
Y = [y0,y1,y2,y3,y4,y5,y6,y7,y8,y9,y10,y11,y12,y13,y14,y15,y16,y17,y18,y19,y20,y21,y22,y23,y24,y25,y26,y27,y28,y29,y30,y31,y32,y33,y34,y35,y36,y37,y38,y39,y40,y41,y42,y43,y44,y45,y46,y47,y48,y49,y50,y51,y52,y53,y54,y55,y56,y57,y58,y59,y60,y61,y62,y63,y64]
# [1, 1, 1, 1, 0, 1, 1]
# O= [0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 1, 0, 0, 1, 1, 1, 0, 0, 0, 1, 0, 1, 1, 1, 1, 0, 0, 1, 0, 1, 0, 0, 0, 1, 1, 1, 0, 1, 1, 1, 1, 0, 0, 1, 0, 1, 0, 0, 0, 1, 1, 0, 0, 0, 1, 1, 1, 1, 0, 1, 0, 1, 1, 1, 1, 1, 0, 1, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 0, 1, 1, 0, 0, 1, 1, 0, 1, 0, 1, 1, 0, 1, 1, 1, 0, 1, 1, 0, 0, 0, 1, 0, 0, 1, 1, 1, 0, 1, 0, 1, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 1, 0, 0, 1, 1, 1, 0, 0, 0, 1, 0, 1, 1, 1, 1, 0, 0, 1, 0, 1, 0, 0, 0, 1, 1, 1, 0, 1, 1, 1, 1, 0, 0, 1, 0, 1, 0, 0, 0, 1, 1, 0, 0, 0, 1, 1, 1, 1, 0, 1, 0, 1, 1, 1]


#We can consider 's' as a register that will be shifted for a specified number of times. Thus, there will exist more entries than simply those defined in 's'.
#We therefore initialise a vector 'add' that will be appended to s to hold all the update bits (one vector for equations with respect to keystream bits S and one with respect the the linear approximation G).
add=list(0for i in (ellipsis_iter(_sage_const_1 ,Ellipsis,_sage_const_256 )))
S = s+add
G = s+add

#Generate equations for update using output bits
# S[6] = S[0]+S[2]+S[3]+O[0]
for i in range(_sage_const_6 ,n):
    S[i] = (S[i-_sage_const_6 ]+S[i-_sage_const_4 ]+S[i-_sage_const_3 ]+Y[i-_sage_const_6 ])
    # S[i] = (S[i-6]+S[i-5]+S[i-4]+S[i-1]+O[i-6])
#     S[i] = (S[i-6]+S[i-3]+O[i-6])
    # S[i] = (S[i-6]+S[i-5]+S[i-2]+S[i-1]+O[i-6])
    # S[i] = (S[i-6]+S[i-4]+O[i-6])
    #S[i] = (S[i-4]+S[i-3]+O[i-6])
    # S[i] = (S[i-5]+S[i-4]+S[i-1]+O[i-6])

    # print(i, S[i])

#Generate equations for update using linear approximation
for i in range(_sage_const_7 ,n):
    #G_approx = s1+s2+s6 with bias agreeing 48 for the true update function s1+s2+s6+s3s5s7
    G[i] = S[i-_sage_const_7 ]+S[i-_sage_const_6 ]+S[i-_sage_const_2 ]+S[i-_sage_const_5 ]*S[i-_sage_const_3 ]*S[i-_sage_const_1 ]
#   

    #G_approx = r0+r1 with bias agreeing 48 for the true update function  r0 + r1 + r2r3 + r4r5r6.
    # G[i] = S[i-7]+S[i-6]
    
    #G_approx = r0+r1+r2 with bias agreeing 48 for the true update function  r0 + r1 + r2r3 + r4r5r6.
    # G[i] = S[i-7]+S[i-6]+S[i-5]
    
    #G_approx = r0+r1+r3 with bias agreeing 48 for the true update function  r0 + r1 + r2r3 + r4r5r6.
    # G[i] = S[i-7]+S[i-6]+S[i-4]
    
    #G_approx = r0+r1+r2+r3 with bias agreeing 48 for the true update function  r0 + r1 + r2r3 + r4r5r6.
    # G[i] = S[i-7]+S[i-6]+S[i-5]+S[i-4]
    
    #G_approx = s1+s2+s3 with bias agreeing 24 for the true update function s1+s2+s3s4+s5s6s7
    # G[i] = S[i-7]+S[i-6]+S[i-5]
    #G_approx = s1+s2+s3 with bias agreeing 24 for the true update function s1+s2+s3s4+s5s6s7
    # G[i] = S[i-7]+S[i-6]+S[i-4]
    #G_approx = s1+s2+s3+s4 with bias agreeing 24 for the true update function s1+s2+s3s4+s5s6s7
    # G[i] = S[i-7]+S[i-6]+S[i-5]+S[i-4]
#     G[i] = S[i-6]+S[i-5]
    
    
    
    # print(i,G[i])
    #create a matrix that will hold the final equations (the sum of those given with respect to the keystream bits + those given by the linear approximation)
EQ = list(var('eq%d' %i) for i in (ellipsis_iter(_sage_const_0 ,Ellipsis,_sage_const_256 )))


# Combine both forms of equations
# print(S)
# print(G)
for i in range(_sage_const_7 ,n):
    EQ[i] = (S[i]+G[i])
    # print(i,EQ[i])
# for i in range(7,40):
    # print(i,EQ[i])
#
EQ_1=EQ[_sage_const_7 :n]
# 


#BUILD OUTPUT

V = [_sage_const_0 ,_sage_const_0 ,_sage_const_0 ,_sage_const_0 ,_sage_const_0 ,_sage_const_0 ,_sage_const_0 ]

#Define nonlinear feedback variable
fS = var('fS')


#initialise a random initial vector
for i in range(_sage_const_7 ):
    # V[i]= ntl.ZZ_random(2)
    V = [_sage_const_1 , _sage_const_0 , _sage_const_1 , _sage_const_0 , _sage_const_0 , _sage_const_0 , _sage_const_1 ]
    # V = [0, 1, 0, 1, 0, 0, 1]
#     V = [1, 1, 1, 1, 0, 1, 1]
#     V = [1, 1, 1, 0, 0, 1, 1]
# print(V)
#Define register S
RegS = [_sage_const_0 ]*len(V)
for i in range(len(V)):
    RegS[i] = V[i]
print(V)
b = [_sage_const_0 ]*_sage_const_207 
#initialise a vector for the keystream
O = [_sage_const_0 ]*_sage_const_200 

for i in range(len(V)):
    b[i] = V[i]
#we will only produce exactly as much keystream is needed to check our assumption
for i in range(_sage_const_200 ):
#
   # Generate ouput bit z
    O[i] = mod((RegS[_sage_const_0 ]+RegS[_sage_const_2 ]+RegS[_sage_const_3 ]+RegS[_sage_const_6 ]),_sage_const_2 )

    #Calculate feedback bit for RegS (NONLINEAR)
    # fS= mod((RegS[0]+RegS[1]+RegS[5]+(RegS[2]*RegS[4]*RegS[6])),2)
    fS= mod((RegS[_sage_const_0 ]+RegS[_sage_const_1 ]+RegS[_sage_const_5 ]+(RegS[_sage_const_2 ]*RegS[_sage_const_4 ]*RegS[_sage_const_6 ])),_sage_const_2 )

    b[i+_sage_const_7 ] = fS
#
   # Step register S by one and enter feedback into lsb
    for i in range(_sage_const_6 ):
        RegS[i]=RegS[i+_sage_const_1 ]

    RegS[_sage_const_6 ] = fS
# print(EQ[8])
# print(EQ_1[0])
# print(EQ_1[1])
# print(EQ_1[31])
# print(EQ_1[32])
# I = R.ideal(EQ_1) ;
# I.variety()
#V = [1, 0, 1, 0, 0, 0, 1]

# O = [0, 1, 1, 0, 1, 0, 0, 1, 0, 0, 1, 1, 1, 0, 0, 0, 1, 0, 1, 1, 1, 0, 0, 0, 1, 0, 0, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 1, 0, 1, 1, 0, 1, 0, 0, 0, 0, 1, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 1, 0, 0, 0, 1, 0, 1, 0, 1, 1, 0, 1, 0, 0, 1, 0, 0, 1, 1, 1, 0, 0, 0, 1, 0, 1, 1, 1, 0, 0, 0, 1, 0, 0, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 1, 0, 1, 1, 0, 1, 0, 0, 0, 0, 1, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 1, 0, 0, 0, 1, 0, 1, 0, 1, 1, 0, 1, 0, 0, 1, 0, 0, 1, 1, 1, 0, 0, 0, 1, 0, 1, 1, 1, 0, 0, 0, 1, 0, 0, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 1, 0, 1, 1, 0, 1, 0, 0, 0, 0, 1, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0]

for i in range(len(EQ_1)):
    EQ_1[i]=EQ_1[i].subs(y0=O[_sage_const_0 ], y1=O[_sage_const_1 ], y2=O[_sage_const_2 ], y3=O[_sage_const_3 ], y4=O[_sage_const_4 ], y5=O[_sage_const_5 ], y6=O[_sage_const_6 ], y7=O[_sage_const_7 ], y8=O[_sage_const_8 ], y9=O[_sage_const_9 ], y10=O[_sage_const_10 ], y11=O[_sage_const_11 ], y12=O[_sage_const_12 ], y13=O[_sage_const_13 ], y14=O[_sage_const_14 ], y15=O[_sage_const_15 ], y16=O[_sage_const_16 ], y17=O[_sage_const_17 ], y18=O[_sage_const_18 ], y19=O[_sage_const_19 ], y20=O[_sage_const_20 ], y21=O[_sage_const_21 ], y22=O[_sage_const_22 ], y23=O[_sage_const_23 ], y24=O[_sage_const_24 ], y25=O[_sage_const_25 ], y26=O[_sage_const_26 ], y27=O[_sage_const_27 ], y28=O[_sage_const_28 ], y29=O[_sage_const_29 ], y30=O[_sage_const_30 ], y31=O[_sage_const_31 ], y32=O[_sage_const_32 ], y33=O[_sage_const_33 ])
# for i in range(len(EQ_1)):
#     print(i,EQ_1[i])

#Define the polynomial ring over which the equations will be solved
R1 = PolynomialRing(GF(_sage_const_2 ), names=('s0', 's1', 's2', 's3', 's4', 's5',)); (s0, s1, s2, s3, s4, s5,) = R1._first_ngens(6)

# Consider the system of equations as an ideal over a polynomial ring R1
I = R1.ideal(EQ_1)
# print(len(I))
# What initial values satisfy this ideal
I.variety()
# 
#Print initial values
# print(J)

#Print 'n' as proof the code has finished
print(n)

